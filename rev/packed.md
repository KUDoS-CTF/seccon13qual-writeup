# packed
パッキングされているバイナリのようだが、UPXを使ってアンパックすると   
Flagcheckerの挙動をしないバイナリになるみたいなので、アンパック前のバイナリでgdbで解析を行う。

すると大体以下のことがわかる。  
* 0x44ee1f:   
syscall(read)の返り値を0x31と比較していることからflagは0x31文字
```
    0x44ee1d 0f05               <NO_SYMBOL>   syscall  
*-> 0x44ee1f 83f831             <NO_SYMBOL>   cmp    eax, 0x31 
```

* 0x44ee34~0x44ee3a:   
stack上のデータ(ユーザの入力値)に対してループでxorの処理をしている。   
xorする値の値が格納されている開始番地はrsi。
```
    0x44ee2c 488dbc2470ffffff   <NO_SYMBOL>   lea    rdi, [rsp - 0x90] 
 -> 0x44ee34 ac                 <NO_SYMBOL>   lods   al, BYTE PTR ds:[rsi] 
    0x44ee35 3007               <NO_SYMBOL>   xor    BYTE PTR [rdi], al 
    0x44ee37 48ffc7             <NO_SYMBOL>   inc    rdi 
    0x44ee3a e0f8               <NO_SYMBOL>   loopne 0x44ee34 
```

* 0x44ee82~0x44ee8d
xorした入力値とメモリ上の値をループで一文字ずつ比較している
```
*-> 0x44ee82 ac                 <NO_SYMBOL>   lods   al, BYTE PTR ds:[rsi] 
    0x44ee83 3807               <NO_SYMBOL>   cmp    BYTE PTR [rdi], al 
    0x44ee85 0f95c0             <NO_SYMBOL>   setne  al 
    0x44ee88 08c2               <NO_SYMBOL>   or     dl, al 
    0x44ee8a 48ffc7             <NO_SYMBOL>   inc    rdi 
    0x44ee8d e0f3               <NO_SYMBOL>   loopne 0x44ee82 
```

上記からループで使用しているxorの値と比較文字列をメモリ上から撮ってきて、以下のソルバを作成。
```python
 a = [
0xe8,0x4a,0x00,0x00,0x00,0x83,0xf9,0x49,
0x75,0x44,0x53,0x57,0x48,0x8d,0x4c,0x37,
0xfd,0x5e,0x56,0x5b,0xeb,0x2f,0x48,0x39,
0xce,0x73,0x32,0x56,0x5e,0xac,0x3c,0x80,
0x72,0x0a,0x3c,0x8f,0x77,0x06,0x80,0x7e,
0xfe,0x0f,0x74,0x06,0x2c,0xe8,0x3c,0x01,
0x77
]

b = [
0xbb,0x0f,0x43,0x43,0x4f,0xcd,0x82,0x1c,
0x25,0x1c,0x0c,0x24,0x7f,0xf8,0x2e,0x68,
0xcc,0x2d,0x09,0x3a,0xb4,0x48,0x78,0x56,
0xaa,0x2c,0x42,0x3a,0x6a,0xcf,0x0f,0xdf,
0x14,0x3a,0x4e,0xd0,0x1f,0x37,0xe4,0x17,
0x90,0x39,0x2b,0x65,0x1c,0x8c,0x0f,0x7c,
0x7d
]

flag = ''
for i in range(len(a)):
    flag += chr(a[i]^b[i])
print(flag) 
```
